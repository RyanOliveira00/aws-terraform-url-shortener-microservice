name: ðŸš€ Deploy to AWS ECS

on:
  push:
    branches: [ main, master ]
    paths:
      - 'src/**'
      - 'iac/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'src/**'
      - 'iac/**'
  workflow_dispatch:  # Permite execuÃ§Ã£o manual

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: url-shortener
  ENVIRONMENT: dev

jobs:
  # Job 1: Testes e ValidaÃ§Ãµes
  test:
    name: ðŸ§ª Tests & Validation
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: ðŸ“¦ Install Dependencies - API Service
        run: |
          cd src/api-service
          pip install -r requirements.txt

      - name: ðŸ“¦ Install Dependencies - Processing Service
        run: |
          cd src/processing-service
          pip install -r requirements.txt

      - name: ðŸ” Lint Python Code
        run: |
          pip install flake8
          # Lint API Service
          flake8 src/api-service/app.py --max-line-length=100 --ignore=E501,W503 || true
          # Lint Processing Service
          flake8 src/processing-service/worker.py --max-line-length=100 --ignore=E501,W503 || true

      - name: ðŸ§ª Test Docker Builds
        run: |
          # Test API Service Docker build
          cd src/api-service
          docker build -t test-api-service:latest .
          
          # Test Processing Service Docker build
          cd ../processing-service
          docker build -t test-processing-service:latest .

      - name: ðŸ”§ Validate Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: ðŸ—ï¸ Terraform Init
        run: |
          cd iac
          terraform init -backend=false

      - name: âœ… Terraform Validate
        run: |
          cd iac
          terraform validate

      - name: ðŸ“‹ Terraform Plan (Dry Run)
        run: |
          cd iac
          echo "ðŸ” Executando terraform plan (dry run)..."
          if terraform plan -out=tfplan; then
            echo "âœ… Terraform plan executado com sucesso"
          else
            echo "âš ï¸ Terraform plan falhou - esperado sem credenciais AWS"
            echo "âœ… ValidaÃ§Ã£o de sintaxe jÃ¡ foi feita no step anterior"
          fi

  # Job 2: Build e Push para ECR
  build-and-push:
    name: ðŸ³ Build & Push to ECR
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    outputs:
      api-image: ${{ steps.build-api.outputs.image }}
      processing-image: ${{ steps.build-processing.outputs.image }}
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ·ï¸ Generate Image Tags
        id: tags
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT

      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: ðŸ“‹ Get ECR Repository URLs
        id: ecr-repos
        run: |
          # Configurar Terraform para obter outputs
          cd iac
          terraform init
          
          # Verificar se os outputs existem
          echo "ðŸ” Verificando outputs do Terraform..."
          if terraform output > /dev/null 2>&1; then
            echo "âœ… Outputs encontrados, obtendo URLs dos repositÃ³rios ECR..."
            API_ECR_URI=$(terraform output -raw api_service_ecr_repository_url)
            PROCESSING_ECR_URI=$(terraform output -raw processing_service_ecr_repository_url)
          else
            echo "âš ï¸ Nenhum output encontrado. Usando nomes padrÃ£o dos repositÃ³rios..."
            # Construir URLs baseado no padrÃ£o AWS ECR
            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            AWS_REGION="${{ env.AWS_REGION }}"
            API_ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-api-service"
            PROCESSING_ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-processing-service"
          fi
          
          echo "ðŸ“‹ API ECR URI: ${API_ECR_URI}"
          echo "ðŸ“‹ Processing ECR URI: ${PROCESSING_ECR_URI}"
          
          echo "api-ecr-uri=${API_ECR_URI}" >> $GITHUB_OUTPUT
          echo "processing-ecr-uri=${PROCESSING_ECR_URI}" >> $GITHUB_OUTPUT

      - name: ðŸ”‘ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ðŸ³ Build and Push API Service
        id: build-api
        run: |
          cd src/api-service
          
          # Build para arquitetura AMD64 (compatÃ­vel com ECS)
          docker build --platform linux/amd64 -t ${{ steps.ecr-repos.outputs.api-ecr-uri }}:latest .
          docker build --platform linux/amd64 -t ${{ steps.ecr-repos.outputs.api-ecr-uri }}:${{ steps.tags.outputs.short-sha }} .
          docker build --platform linux/amd64 -t ${{ steps.ecr-repos.outputs.api-ecr-uri }}:${{ steps.tags.outputs.timestamp }} .
          
          # Push all tags
          docker push ${{ steps.ecr-repos.outputs.api-ecr-uri }}:latest
          docker push ${{ steps.ecr-repos.outputs.api-ecr-uri }}:${{ steps.tags.outputs.short-sha }}
          docker push ${{ steps.ecr-repos.outputs.api-ecr-uri }}:${{ steps.tags.outputs.timestamp }}
          
          echo "image=${{ steps.ecr-repos.outputs.api-ecr-uri }}:${{ steps.tags.outputs.short-sha }}" >> $GITHUB_OUTPUT

      - name: ðŸ³ Build and Push Processing Service
        id: build-processing
        run: |
          cd src/processing-service
          
          # Build para arquitetura AMD64 (compatÃ­vel com ECS)
          docker build --platform linux/amd64 -t ${{ steps.ecr-repos.outputs.processing-ecr-uri }}:latest .
          docker build --platform linux/amd64 -t ${{ steps.ecr-repos.outputs.processing-ecr-uri }}:${{ steps.tags.outputs.short-sha }} .
          docker build --platform linux/amd64 -t ${{ steps.ecr-repos.outputs.processing-ecr-uri }}:${{ steps.tags.outputs.timestamp }} .
          
          # Push all tags
          docker push ${{ steps.ecr-repos.outputs.processing-ecr-uri }}:latest
          docker push ${{ steps.ecr-repos.outputs.processing-ecr-uri }}:${{ steps.tags.outputs.short-sha }}
          docker push ${{ steps.ecr-repos.outputs.processing-ecr-uri }}:${{ steps.tags.outputs.timestamp }}
          
          echo "image=${{ steps.ecr-repos.outputs.processing-ecr-uri }}:${{ steps.tags.outputs.short-sha }}" >> $GITHUB_OUTPUT

      - name: ðŸ“Š Build Summary
        run: |
          echo "## ðŸ³ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Image | Tag |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| API Service | \`${{ steps.ecr-repos.outputs.api-ecr-uri }}\` | \`${{ steps.tags.outputs.short-sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Processing Service | \`${{ steps.ecr-repos.outputs.processing-ecr-uri }}\` | \`${{ steps.tags.outputs.short-sha }}\` |" >> $GITHUB_STEP_SUMMARY

  # Job 3: Deploy para ECS
  deploy:
    name: ðŸš€ Deploy to ECS
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: ðŸ“‹ Get ECS Cluster Info
        id: ecs-info
        run: |
          cd iac
          terraform init
          
          # Verificar se os outputs existem
          echo "ðŸ” Verificando outputs do Terraform..."
          if terraform output > /dev/null 2>&1; then
            echo "âœ… Outputs encontrados, obtendo nome do cluster ECS..."
            ECS_CLUSTER=$(terraform output -raw ecs_cluster_name)
          else
            echo "âš ï¸ Nenhum output encontrado. Usando nome padrÃ£o do cluster..."
            ECS_CLUSTER="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster"
          fi
          
          echo "ðŸ“‹ ECS Cluster: ${ECS_CLUSTER}"
          echo "cluster-name=${ECS_CLUSTER}" >> $GITHUB_OUTPUT

      - name: ðŸ”„ Update API Service
        run: |
          aws ecs update-service \
            --cluster ${{ steps.ecs-info.outputs.cluster-name }} \
            --service "${PROJECT_NAME}-${ENVIRONMENT}-api-service" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: ðŸ”„ Update Processing Service
        run: |
          aws ecs update-service \
            --cluster ${{ steps.ecs-info.outputs.cluster-name }} \
            --service "${PROJECT_NAME}-${ENVIRONMENT}-processing-service" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: â³ Wait for API Service Stability
        run: |
          echo "â³ Aguardando estabilizaÃ§Ã£o do API Service..."
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs-info.outputs.cluster-name }} \
            --services "${PROJECT_NAME}-${ENVIRONMENT}-api-service" \
            --region ${{ env.AWS_REGION }}
          echo "âœ… API Service estabilizado"

      - name: â³ Wait for Processing Service Stability
        run: |
          echo "â³ Aguardando estabilizaÃ§Ã£o do Processing Service..."
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs-info.outputs.cluster-name }} \
            --services "${PROJECT_NAME}-${ENVIRONMENT}-processing-service" \
            --region ${{ env.AWS_REGION }}
          echo "âœ… Processing Service estabilizado"

      - name: ðŸ“Š Service Status
        run: |
          echo "ðŸ“Š Status dos serviÃ§os apÃ³s deploy:"
          aws ecs describe-services \
            --cluster ${{ steps.ecs-info.outputs.cluster-name }} \
            --services "${PROJECT_NAME}-${ENVIRONMENT}-api-service" "${PROJECT_NAME}-${ENVIRONMENT}-processing-service" \
            --query 'services[*].[serviceName,runningCount,desiredCount,taskDefinition]' \
            --output table \
            --region ${{ env.AWS_REGION }}

  # Job 4: Testes de IntegraÃ§Ã£o
  integration-tests:
    name: ðŸ§ª Integration Tests
    runs-on: ubuntu-latest
    needs: deploy
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: ðŸ”— Get API Endpoint
        id: api-endpoint
        run: |
          cd iac
          terraform init
          
          # Verificar se os outputs existem
          echo "ðŸ” Verificando outputs do Terraform..."
          if terraform output > /dev/null 2>&1; then
            echo "âœ… Outputs encontrados, obtendo endpoint da API..."
            API_ENDPOINT=$(terraform output -raw api_endpoint)
          else
            echo "âš ï¸ Nenhum output encontrado. Tentando descobrir endpoint via AWS..."
            # Tentar obter o endpoint do Load Balancer
            LB_DNS=$(aws elbv2 describe-load-balancers \
              --names "${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-alb" \
              --query 'LoadBalancers[0].DNSName' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$LB_DNS" ] && [ "$LB_DNS" != "None" ]; then
              API_ENDPOINT="http://${LB_DNS}"
            else
              echo "âŒ NÃ£o foi possÃ­vel encontrar o endpoint da API"
              exit 1
            fi
          fi
          
          echo "ðŸ“‹ API Endpoint: ${API_ENDPOINT}"
          echo "endpoint=${API_ENDPOINT}" >> $GITHUB_OUTPUT

      - name: ðŸ¥ Health Check Test
        run: |
          echo "ðŸ¥ Testando health check..."
          
          # Aguardar API ficar disponÃ­vel
          for i in {1..30}; do
            if curl -sf "${{ steps.api-endpoint.outputs.endpoint }}/health" > /dev/null; then
              echo "âœ… API estÃ¡ respondendo"
              break
            fi
            echo "â³ Tentativa $i/30 - aguardando API..."
            sleep 10
          done
          
          # Fazer o teste efetivo
          response=$(curl -s "${{ steps.api-endpoint.outputs.endpoint }}/health")
          echo "Resposta do health check: $response"
          
          # Verificar se contÃ©m "healthy"
          if echo "$response" | grep -q "healthy"; then
            echo "âœ… Health check passou"
          else
            echo "âŒ Health check falhou"
            exit 1
          fi

      - name: ðŸ”— URL Shortening Test
        run: |
          echo "ðŸ”— Testando encurtamento de URL..."
          
          response=$(curl -s -X POST "${{ steps.api-endpoint.outputs.endpoint }}/shorten" \
            -H "Content-Type: application/json" \
            -d '{"url": "https://github.com/actions/checkout"}')
          
          echo "Resposta do encurtamento: $response"
          
          # Verificar se contÃ©m "success": true
          if echo "$response" | grep -q '"success": *true'; then
            echo "âœ… Teste de encurtamento passou"
          else
            echo "âŒ Teste de encurtamento falhou"
            exit 1
          fi

      - name: ðŸ“Š Integration Test Summary
        run: |
          echo "## ðŸ§ª Integration Test Results" >> $GITHUB_STEP_SUMMARY
          echo "| Test | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Health Check | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| URL Shortening | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”— **API Endpoint**: ${{ steps.api-endpoint.outputs.endpoint }}" >> $GITHUB_STEP_SUMMARY

  # Job 5: NotificaÃ§Ã£o
  notify:
    name: ðŸ“¢ Notification
    runs-on: ubuntu-latest
    needs: [test, build-and-push, deploy, integration-tests]
    if: always()
    steps:
      - name: ðŸ“¢ Deployment Status
        run: |
          if [[ "${{ needs.test.result }}" == "success" && "${{ needs.build-and-push.result }}" == "success" && "${{ needs.deploy.result }}" == "success" && "${{ needs.integration-tests.result }}" == "success" ]]; then
            echo "ðŸŽ‰ Deploy realizado com sucesso!"
            echo "## ðŸŽ‰ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
            echo "Todos os testes passaram e a aplicaÃ§Ã£o foi deployada com sucesso." >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Deploy falhou em alguma etapa"
            echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "Verifique os logs dos jobs para mais detalhes." >> $GITHUB_STEP_SUMMARY
          fi 